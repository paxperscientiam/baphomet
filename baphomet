#!/usr/bin/env bash
# shellcheck disable=2093
#set -x
#set -u
shopt -s extglob
shopt -s nullglob
shopt -s nocasematch
PS3="What is thy bidding?: "
unset KMND
unset CDPATH
unset rrr
unset gray
unset none
unset _gray
unset none2
unset yyy
KMND=('\emacs')
:
function cleanup {
    printf '\n\n%b%s\e[0m\n\n' "${inverse}" $'I'\''ll be seeing you.'
    printf 'Cleaning up ... '
    kill %1 >/dev/null 2>&1
    wait
    (sleep 20
     if hard_check "${daemon}"
     then
         slay "${daemon}" >/dev/null 2>&1
     fi
    ) &
    disown %1
    jobs
    printf 'done.\n\n'

    [[ "${#daemon}" -gt 0 ]] && \
        printf 'Note: The daemon %b%s=\e[0m may have materialized despite interruption.\n' "${rrr}" "${daemon^^}" && \
        printf "Attempting to slay in the background.\\n\\n" && \
        printf 'Enter %s to be sure.\n' $'`baphomet -l`'
    exit
}
trap cleanup TERM INT SIGINT SIGTERM
:
case ${@:1:1} in
    -x|--escape)
        exec command emacs "${@:2}"
        ;;
    -Q|--quick)
        KMND+=("-Q ${@:2}")
        eval exec "${KMND[*]}"
        ;;
esac
prettyify () {
    rrr=$'\x1b[38;2;250;0;0m'
    gray=$'\x1b[38;2;100;100;100m'
    none=$'\x1b[0m'
    #
    _gray=$'\e[37;4;2m'
    none2=$'\e[0m'

    yyy=$'\e[33m'
    rrr=$'\e[91m'
    #
    inverse=$'\e[7m'
    #
    mmm=$'\e[0;36m'
}
# # # # #
# U T I L
# # # # #
containsElement () {
    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1
}

userTest () {
    [[ ${#@} -ne 0 ]] && USER="${1}"
    :
    id -u "${USER}" >/dev/null 2>&1
    if [[ $? -eq 1 ]]; then
        printf 'The user %s is not known to exist.\n' "${USER^^}"; return 1
    fi
    return 0
}
:
EMACS_SOCKET_DIR="/tmp/baphomet/${USER}/"
[[ ! -d $EMACS_SOCKET_DIR  ]] && mkdir -p "${EMACS_SOCKET_DIR}"


DAEMON_SPLASH=$'(progn (defconst baphomet-buffer "*BAPHOMET WELCOMES YOU*")
(with-current-buffer (get-buffer-create baphomet-buffer))
(switch-to-buffer baphomet-buffer) (setq header-line-format "BAPHOMET"))'

#LISP_FRAME_CHECK=$'(if (> (length (frame-list)) 1) '"'"'t)'
:
LISP_BUFFER_COUNT=$'(length (cl-remove-if-not '"'"'buffer-file-name (buffer-list)))'
:
LISP_BUFFER_LIST=$'(concat (daemonp) ";" (mapconcat '"'"'identity (delete '"'"'nil (mapcar '"'"'buffer-file-name (buffer-list))) "+++"))'
:
LISP_PID=$'(emacs-pid)'
:
:

hard_check () {
    local socket="${EMACS_SOCKET_DIR}/${1}"
    [[ -S $socket ]] && return 0
    :
    return 1
}

list_sockets () {
    local socket
    local daemon
    :
    arrSockets=("${EMACS_SOCKET_DIR:?}"/*)
    arrDaemons=()
    :
    for socket in "${arrSockets[@]}"
    do
        if [[ -S $socket ]]; then
            arrDaemons+=("$(basename "${socket^^}")")
        fi
    done
    pd=("${arrDaemons[@]//\!/\/}")
    pd=("${pd[@]/%/=}")
}
# generate sockets array
list_sockets

pretty () {
    # make it presentable
    ## takes a reference
    x="${!1//\!/\/}"
    x="${x/%/=}"
    eval "${1}=${x}"
}


query_socket () {
    socket="${EMACS_SOCKET_DIR}/${1}"
}



query_daemon () {
    unset result
    local element
    local CMD="${1}"
    :
    for s in "${arrSockets[@]}"
    do
        read -r element < <(nc -U "${s}" <<< \
                               $"-eval ${CMD// /&_}" | \
                                awk $'FNR == 2 {printf $2}')
        result+=("${element}")
    done
}

message_daemon () {
    unset result
    local CMD="${1}"
    if [[ "${#2}" -gt 0 ]]; then
	      query_socket "${2}"
        read -r result < <(nc -U "${socket}" <<< \
			                        $"-eval ${CMD// /&_}" | \
				                       awk $'FNR == 2 {printf $2}')
    fi

}


slay () {
    local socket
    socket="${EMACS_SOCKET_DIR}/$(basename "${1}")"
    nc -U "${socket}" <<< '-eval (kill-emacs)' >/dev/null 2>&1 &
    printf 'Slaying daemon known as %b%s=\e[0m ...' "${yyy}" "$(basename "${socket^^}")"
    wait
    printf ' done.\n'
    printf ' So slain.\n'
}

sanitize () {
    unset result
    :
    result="${1//[^a-zA-Z0-9\/]/}"
    result="${result////!}"
    result="${result%!}"
    result="${result#!}"
}


msg () {
    printf '%b\n\n \u2605  ' "${inverse}"
    if [[ $1 -eq 201 ]]; then
        printf 'Summoning the daemon \b%b ...' ${2:+" \\e[31m${2^^}=\\e[m\\e[7m"}
        wait "${3}"
        printf ' done. \n'
        printf 'So summoned.\n'
    elif [[ $1 -eq 204 ]]; then
        printf '%s' $'May you live long and prosper.'
    elif [[ $1 -eq 400 ]]; then
        printf '\e[31mBad choice.\e[0m\n'
    elif [[ $1 -eq 404 ]]; then
        printf 'The daemon \b%b was not found!\n' ${2:+" \\e[31m${2^^}=\\e[m\\e[7m"}
    elif [[ $1 -eq 0404 ]]; then
        printf '%s' $'No daemons to be found.'
    elif [[ $1 -eq 499 ]]; then
        printf '%s' $'Request cancelled.'
    fi
    printf '\e[0m\n\n'
#    printf -v ender %q "${none2}" && eval
}

printf -v DISPLAY_HEADER '\e[37;4;2m%s\e[0m\n' "${EMACS_SOCKET_DIR}"


while [[ ${#@} -ne 0 ]]
do
    case $1 in
        -p|--pretty)
            prettyify
            shift
            ;;
        -i|--interactive|-is|--shell)
            break  3
            ;;
        -u|--user)
            UZR="${2}"
            [[ ${#UZR} -eq 0 ]] && \
                printf 'A user must be specified!\n' && exit 1
            if ! userTest "${UZR}"; then exit 1; fi
            :
            shift 2
            USER="${UZR}" exec "${0}" "${@}"
            ;;
        -v|--verbose)
            B_VERBOSE=$(( B_VERBOSE+1 ))
            shift
            ;;
        -vv|--very-verbose)
            B_VERBOSE=2
            shift
            ;;
        --join|-j)
            B_STATE="JOIN"
            daemon="${2}"
            :
            query_socket "${daemon}"
            :
            if [[ ${#daemon} -eq 0 ]]; then
                [[ "${#arrSockets[@]}" -eq 0 ]] && msg 0404 && exit
                printf '\e[33m%.0s-' {1..20}; echo
                printf '     DAEMON MENU\n'
                printf '%.0s-' {1..20};  printf '\e[0m\n\n'
                printf '%s' "${DISPLAY_HEADER}"

                select daemon in "${arrDaemons[@]}" ${OFFER:+"Commune with $OFFER="} "Quit"
                do
                    [[ "${daemon^^}" == "QUIT"  ]] && \
                        msg 204 && \
                        exit 0
                    :
                    if [[ $INTERACTIVE == TRUE ]]
                    then
                        printf '\n\e[31mName a buffer or file by absolute path\e[0m: '
                        read -r EMACS_BUFFER_NAME
                        break
                    fi
                    exec "${0}" -j "${daemon}"
                done
            fi
            :
            query_socket "${daemon}"
            if containsElement "${socket}" "${arrSockets[@]}"
            then
                :
                shift 2
                continue
            else
                msg 404 "${daemon}"
                shift 2
                OFFER="${daemon}"
                exec "${0}" --list
            fi
            exit
            ;;
        --list|--list-daemons|-l|-ls)
            [[ $B_VERBOSE -gt 0 ]] && query_daemon "${LISP_BUFFER_COUNT}"; arrBuffers=("${result[@]}")
            [[ $B_VERBOSE -gt 1 ]] && query_daemon "${LISP_PID}"; arr_pids=("${result[@]}")

            printf '%s%s%s\n\n' "${_gray}" "${EMACS_SOCKET_DIR}" "${none2}"
            paste <(printf '%s\n' $'Daemons' "${pd[@]:- None found}") \
                  <([[ $B_VERBOSE -gt 0 ]] && printf '%s\n' $'Files #' "${arrBuffers[@]:- –}") \
                  <([[ $B_VERBOSE -gt 1 ]] && printf '%s\n' $'PID' "${arr_pids[@]:- –}") \
                | sed $'s/\t/,,/g' |  column -s ',' -t
            :
            if  [[ $INTERACTIVE == TRUE ]]; then
                printf '\n\n%s%s%s\n' "${rrr}" 'What do you desire?' "${none2}"
                select option in 'Return' 'Quit'
                do
                    case $option in
                        'Return')
                            exec "${0}" -i
                            ;;
                        'Quit')
                            exit
                            ;;
                    esac
                done
            fi
            exit
            ;;
        --list-buffers)
            query_daemon "${LISP_BUFFER_LIST}"
	          printf '\e[37;4;2m%-20s\e[0m\n' "File buffers"
            R="${result[0]//$'+++'/$'\n'}"
            R="${R//\"/}"
	          #            paste  <(printf '%s' "${R}")
	          printf '%s\n' "${R}"|tr ';' '\n'
            exit
            ;;
        --kill-all|-ka)
            shopt -u nocasematch
            read -r -e -p "Beware! This command kills all buffers, even unsaved ones. Proceed? [Y/*]: "  choice
            [[ ! $choice =~ [Y] ]] && msg 499 && exit 0
            printf '\n%s\n\n' "Proceeding."
            DIE="DIE"
            ;&
        --stop|--kill|-k|--slay)
            IFS=,
            daemons="${2}"
            :
            printf '%s' "${DISPLAY_HEADER}"
            [[ "${#arrSockets[@]}" -eq 0 ]] && \
                msg 0404  && exit
            :
            if [[ $DIE == "DIE" ]]; then
                for socket in "${arrSockets[@]}"
                do
                    slay "${socket}"
                done
                exit
            fi
            :
            if [[ ${#daemons} -eq 0 ]]
            then
                printf "Choose a daemon to slay:\\n" && \
                    select daemon in "${arrDaemons[@]}"
                    do
                        message_daemon "${LISP_BUFFER_COUNT}" "${daemon}"
                        if [[ $result -gt 0 ]]
                        then
			                      shopt -u nocasematch
                            read -r -e -p "Beware! ${result} file buffers will be killed. Proceed? [Y/*]: " choice
                            [[ ! $choice =~ [Y] ]] && msg 499 && exit 0
                            printf '\n%s\n\n' "Proceeding."
                        fi
                        query_socket "${daemon}"
                        slay "${socket}"
                        exit
                    done
            else
                for daemon in $daemons; do
                    query_socket "${daemon}"
                    if containsElement "${socket}" "${arrSockets[@]}"
                    then
                        slay "${socket}"
                    else
                        msg 404 "${daemon}"
                    fi
                done
            fi
            :
            exit
            ;;
        --file|-f|--buffer|-b)
            if [[ ${#2} -eq 0 ]]; then
                printf 'No file or buffer specified!\n';exit
            else
                EMACS_BUFFER_NAME="${2}"
            fi
            ;;
        --start|--summon|-c|-s)
            IFS=,
            daemons="${2}"
            :
            if [[ ${#daemons} -eq 0 ]]; then
                if [[ ${#arrDaemons[*]} -eq 0 ]]; then
                    daemons="server"
                else
                    daemons="${arrDaemons[0]}"
                fi
            fi
            :
            for daemon in $daemons; do
                :
                sanitize "${daemon}"
                daemon="${result}"
                query_socket "${daemon}"
                if containsElement "${socket}" "${arrSockets[@]}"
                then
                    exec "${0}" -j "${daemon}" "${@:3}"
                else
                    \emacs --eval "${DAEMON_SPLASH}" --user="${USER}" --daemon="${socket}" > /dev/null 2>&1 &
                    msg 201 "${daemon^^}" '%1'
                    :
                    if containsElement '--' "${@}" && "${#daemons[@]}" -eq 1
                    then
                        EMACS_BUFFER_NAME="${@}"
                        EMACS_BUFFER_NAME="${EMACS_BUFFER_NAME#*\ \-\-\ }"
                        [[ "${#EMACS_BUFFER_NAME}" -gt 0 ]] && \
                            EMACS_BUFFER_NAME="${EMACS_BUFFER_NAME}" exec "${0}" -j "${daemon}"
                    fi
                fi
            done
            exit
            ;;
        --debug|-d)
            printf 'Debug mode not ready!\n'
            exit
            ;;
        --version)
            printf 'idk check github'
            ;;
        -w|--watch)
            printf 'Watch all daemonic activity.\n'
            exit
            ;;
        -z)
            message_daemon "${LISP_BUFFER_COUNT}" "SHIT"
	          echo $result;exit
            [[ $result -gt 0 ]] && printf '%s\n' "Beware!"
            exit
            # (mapconcat 'identity (delete 'nil (mapcar 'buffer-file-name (buffer-list))) "+++")
            query_daemon "${LISP_BUFFER_LIST}"
            printf "${result[0]}";exit
            r="${result[@]//[^a-zA-Z0-9\/\&\_]/}"
            printf '%s' "${r}"
            exit
            ;;
        --)
            EMACS_BUFFER_NAME="${2}"
            shift
            break 3
            ;;
        --help|-h)
            printf '%s%s\n' \
                   "${rrr}" "BAPHOMET -- manage your emacs daemons"
            printf '%s' "${gray}"
            cat <<'EOF'
  Usage: baphomet [switches] [arguments]
   -h,   --help                      Display (this) help menu
   -s,   --start [name[,name2]]      Summon one or more daemons
   -k,   --kill,                     Slay one or more daemons
         --stop [name[,name2]]
   -ka,  --kill-all                  Slay all daemons
   -j,   --join [name]               Join a daemon with name 'name'
   -l,   --list                      List known daemons
   -v,   --verbose                   Make output verbose
   -vv,  --very-verbose              Make output very verbose
   -b,   --buffer <name>             Specify buffer name

   -i,   --interactive               Interactive mode
   -is,  --shell                     Interactive shell mode
   -x,   --escape                    Exit script, run emacs as normal
   -V,   --version                   Get version of baphomet

   Note:
   When called without arguments, baphomet starts a new daemon
   if necessary and opens a buffer with a default name.
   When called with only a buffer or filename, baphomet joins any daemon
   and creates buffer with specified name.

   Examples:
   - Summon, slay, or join  daemon named 'levi'
   $ `baphomet --start|--slay|--join levi`
   - Join daemon named 'levi' and open buffer 'justice.txt'
   $ `baphomet --join levi -b|-- justice.txt`


   Disclaimer: Execute this script at your own peril.
EOF

            printf '%s' "${none}"
            exit
            ;;
        -*)
            printf '%bUnknown argument "%s"\e[0m\n\v' "${rrr}" "${1}"
            exit 1
            ;;
        *)
            break;
            ;;
                                                                                 esac
                                                                                 [[ "${#@}" -eq 0 ]] && exit
                                                                                done
                                                                                 :
                                                                                 if [[ ${B_STATE} == "JOIN" ]]; then
                                                                                     exec emacsclient -q -c -s "${socket}" -- ${EMACS_BUFFER_NAME:+"$EMACS_BUFFER_NAME"}
                                                                                 fi


                                                                                 case ${@:1:1} in
                                                                                     -i|--interactive)
                                                                                         printf '%s' "${yyy}"
                                                                                         printf '%.0s-' {1..20}; echo
                                                                                         printf '     MAIN MENU\n'
                                                                                         printf '%.0s-' {1..20}; echo
                                                                                         printf '%s' "${none}"
                                                                                         PS3="Make a choice: "
                                                                                         select option in ${arrDaemons[@]:+'List'} ${arrDaemons[@]:+$'Join'} ${arrDaemons[@]:+$'Slay'} $'Summon' $'Shell' $'Quit'
                                                                                         do
                                                                                             option=$(printf '%s' "${option}" |perl -pe 's/\x1b\[[0-9;]*[mG]//g')
                                                                                             :
                                                                                             case $option in
                                                                                                 'List')
                                                                                                     INTERACTIVE=TRUE exec "${0}" -l
                                                                                                     ;;
                                                                                                 'Join')
                                                                                                     INTERACTIVE=TRUE exec "${0}" -j
                                                                                                     ;;
                                                                                                 'Slay')
                                                                                                     INTERACTIVE=TRUE exec "${0}" -k
                                                                                                     ;;
                                                                                                 'Summon')
                                                                                                     printf '\n%bName your daemon\e[0m: ' "${rrr}"
                                                                                                     read -r daemon
                                                                                                     [[ "${daemon^^}" == "BAPHOMET" ]] && printf 'No.\n' && exit 1
                                                                                                     INTERACTIVE=TRUE exec "${0}" -s "${daemon}"
                                                                                                     ;;
                                                                                                 'Shell')
                                                                                                     INTERACTIVE=TRUE exec "${0}" --shell
                                                                                                     ;;
                                                                                                 'Quit')
                                                                                                     msg 204
                                                                                                     exit
                                                                                                     ;;
                                                                                                 *)
                                                                                                     msg 400
                                                                                                     ;;
                                                                                             esac
                                                                                         done
                                                                                         ;;
                                                                                 esac



                                                                                 case ${@:1:1} in
                                                                                     --shell|-is)
                                                                                         exec bash --rcfile <(read -r baphomet_shell < \
                                                                                                                   <(printf '%s' "PS1=$'\\u2605 BAPHOMET >\\e[0m ' ;\
                                       trap \"printf '%s\\n\\n' $'\\111\\47\\154\\154\\40 \\142\\145\\40 \\163\\145\\145\\151\\156\\147\\40 \\171\\157\\165\\56'; tput clear \"  EXIT;\
                                       cd $EMACS_SOCKET_DIR;\
                                       tput clear;\
                                       read -r rows cols < <( stty size );\
                                       cols=\"\$(( \$cols - 20 ))\";\
                                       tput sc ; tput cup \$rows \$cols ; echo \"As above, so below\" ; tput rc;\
                                       alias ls=\"ls -lF\";\
                                       alias help=\"${0} -h\";\
                                       alias list=\"${0} -l\";\
                                       alias lv=\"${0} -v -l\";\
                                       alias lvv=\"${0} -vv -l\";\
                                       alias start=\"${0} -s\";\
                                       alias summon=start;\
                                       alias kill=\"${0} -k\";\
                                       alias kill-all=\"${0} -ka\";\
                                       alias ka=kill-all;\
                                       alias join=\"${0} -j\";\
                                       "); printf '%s' "${baphomet_shell}") -i
                                                                                         ;;
                                                                                 esac

                                                                                 socket="${arrSockets[0]}"
                                                                                 daemon="$(basename "${socket}")"
                                                                                 [[ ${#socket} -gt 0 ]] && \
                                                                                     EMACS_BUFFER_NAME=${1:-'*BAPHOMET WELCOMES YOU*'} exec "${0}" -j "${daemon}"

                                                                                 printf '%b%s\e[0m\n' "${mmm}" "No daemons found. Let's get interactive."
                                                                                 exec "${0}" --interactive
